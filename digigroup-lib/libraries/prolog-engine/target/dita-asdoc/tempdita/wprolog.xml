<?xml version="1.0" encoding="UTF-8"?><apiPackage id="wprolog"><apiName>wprolog</apiName><apiDetail/><apiClassifier id="wprolog:Stack"><apiName>Stack</apiName><shortdesc/><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef></apiClassifierDetail><apiConstructor id="wprolog:Stack:Stack"><apiName>Stack</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>numElements</apiItemName><apiType value="int"/><apiData>0</apiData></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="wprolog:Stack:empty"><apiName>empty</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="Boolean"/></apiReturn></apiOperationDef></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="wprolog:IO"><apiName>IO</apiName><shortdesc> The class IO simply centralises all IO for easy modification </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> The class IO simply centralises all IO for easy modification </apiDesc></apiClassifierDetail><apiOperation id="wprolog:IO:diagnostic"><apiName>diagnostic</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>s</apiItemName><apiType value="String"/></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="wprolog:IO:error"><apiName>error</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>caller</apiItemName><apiType value="String"/></apiParam><apiParam><apiItemName>mesg</apiItemName><apiType value="String"/></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="wprolog:IO:fatalerror"><apiName>fatalerror</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>caller</apiItemName><apiType value="String"/></apiParam><apiParam><apiItemName>mesg</apiItemName><apiType value="String"/></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="wprolog:IO:prologprint"><apiName>prologprint</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>s</apiItemName><apiType value="String"/></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="wprolog:IO:result"><apiName>result</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>s</apiItemName><apiType value="String"/></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="wprolog:IO:trace_"><apiName>trace_</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>s</apiItemName><apiType value="String"/></apiParam></apiOperationDef></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="wprolog:WPrologOutput"><apiName>WPrologOutput</apiName><shortdesc/><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.events:IEventDispatcher</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef></apiClassifierDetail><apiOperation id="wprolog:WPrologOutput:addEventListener"><apiName>addEventListener</apiName><shortdesc>
 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiType value="String"/></apiParam><apiParam><apiItemName>listener</apiItemName><apiType value="Function"/></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiType value="Boolean"/><apiData>false</apiData></apiParam><apiParam><apiItemName>priority</apiItemName><apiType value="int"/><apiData>0</apiData></apiParam><apiParam><apiItemName>weakRef</apiItemName><apiType value="Boolean"/><apiData>false</apiData></apiParam></apiOperationDef><apiDesc>
 </apiDesc></apiOperationDetail><apiInheritDoc/></apiOperation><apiOperation id="wprolog:WPrologOutput:addResult"><apiName>addResult</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>s</apiItemName><apiType value="String"/></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="wprolog:WPrologOutput:clear"><apiName>clear</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="wprolog:WPrologOutput:dispatchEvent"><apiName>dispatchEvent</apiName><shortdesc>
 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>event</apiItemName><apiType value="flash.events:Event"/></apiParam></apiOperationDef><apiDesc>
 </apiDesc></apiOperationDetail><apiInheritDoc/></apiOperation><apiOperation id="wprolog:WPrologOutput:hasEventListener"><apiName>hasEventListener</apiName><shortdesc>
 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiType value="String"/></apiParam></apiOperationDef><apiDesc>
 </apiDesc></apiOperationDetail><apiInheritDoc/></apiOperation><apiOperation id="wprolog:WPrologOutput:removeEventListener"><apiName>removeEventListener</apiName><shortdesc>
 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiType value="String"/></apiParam><apiParam><apiItemName>listener</apiItemName><apiType value="Function"/></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiType value="Boolean"/><apiData>false</apiData></apiParam></apiOperationDef><apiDesc>
 </apiDesc></apiOperationDetail><apiInheritDoc/></apiOperation><apiOperation id="wprolog:WPrologOutput:willTrigger"><apiName>willTrigger</apiName><shortdesc>
 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiType value="String"/></apiParam></apiOperationDef><apiDesc>
 </apiDesc></apiOperationDetail><apiInheritDoc/></apiOperation><apiValue id="wprolog:WPrologOutput:result:get"><apiName>result</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty isBindable="true"/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiType value="String"/></apiValueDef></apiValueDetail></apiValue><apiValue id="wprolog:WPrologOutput:staticEventDispatcher:get"><apiName>staticEventDispatcher</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiType value="flash.events:IEventDispatcher"/></apiValueDef></apiValueDetail></apiValue></apiClassifier><apiClassifier id="wprolog:Character"><apiName>Character</apiName><shortdesc/><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef></apiClassifierDetail><apiOperation id="wprolog:Character:isDigit"><apiName>isDigit</apiName><shortdesc> Determines if a string is digit </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="String"/></apiParam></apiOperationDef><apiDesc> Determines if a string is digit </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:Character:isLetter"><apiName>isLetter</apiName><shortdesc> Determines if a string is letter </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="String"/></apiParam></apiOperationDef><apiDesc> Determines if a string is letter </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:Character:isLowerCase"><apiName>isLowerCase</apiName><shortdesc> Determines if a string is lower case </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="String"/></apiParam></apiOperationDef><apiDesc> Determines if a string is lower case </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:Character:isSpace"><apiName>isSpace</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="String"/></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="wprolog:Character:isUpperCase"><apiName>isUpperCase</apiName><shortdesc> Determines if a string is upper case </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="String"/></apiParam></apiOperationDef><apiDesc> Determines if a string is upper case </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="wprolog:Engine"><apiName>Engine</apiName><shortdesc> An engine is what executes prolog queries.</shortdesc><prolog><author>Michael Winikoff
</author><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> An engine is what executes prolog queries.
</apiDesc></apiClassifierDetail><apiConstructor id="wprolog:Engine:Engine"><apiName>Engine</apiName><shortdesc> 
</shortdesc><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>g</apiItemName><apiOperationClassifier>wprolog:Term</apiOperationClassifier><apiDesc>An initial program - this will be extended
</apiDesc></apiParam><apiParam><apiItemName>prog</apiItemName><apiOperationClassifier>wprolog:Hashtable</apiOperationClassifier><apiDesc>The query to be executed
</apiDesc></apiParam></apiConstructorDef><apiDesc> 
</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="wprolog:Engine:more"><apiName>more</apiName><shortdesc> Used from the GUI when the user hits more.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc> Used from the GUI when the user hits <i>more</i>. All it does is add 
<tt>fail</tt> to the goal and lets the engine do the rest. </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:Engine:runAll"><apiName>runAll</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="wprolog:Engine:run"><apiName>run</apiName><shortdesc> run does the actual work.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiType value="String"/></apiReturn><apiParam><apiItemName>embed</apiItemName><apiType value="Boolean"/></apiParam></apiOperationDef><apiDesc> run does the actual work. </apiDesc></apiOperationDetail></apiOperation><apiValue id="wprolog:Engine:enableTracing"><apiName>enableTracing</apiName><shortdesc> This governs whether tracing is done </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>true</apiData><apiType value="Boolean"/></apiValueDef><apiDesc> This governs whether tracing is done </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="wprolog:TermList"><apiName>TermList</apiName><shortdesc> Simple a list of terms.</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> Simple a list of terms. </apiDesc></apiClassifierDetail><apiConstructor id="wprolog:TermList:TermList"><apiName>TermList</apiName><shortdesc> Used for parsing  clauses.</shortdesc><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>ps</apiItemName><apiOperationClassifier>wprolog:ParseString</apiOperationClassifier><apiData>null</apiData></apiParam></apiConstructorDef><apiDesc> Used for parsing  clauses. </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="wprolog:TermList:resolve"><apiName>resolve</apiName><shortdesc> Looks up which clauses define atoms once and for all </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>db</apiItemName><apiOperationClassifier>wprolog:Hashtable</apiOperationClassifier></apiParam></apiOperationDef><apiDesc> Looks up which clauses define atoms once and for all </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:TermList:toString"><apiName>toString</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiType value="String"/></apiReturn></apiOperationDef></apiOperationDetail></apiOperation><apiValue id="wprolog:TermList:definer"><apiName>definer</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>null</apiData><apiType value="Array"/></apiValueDef></apiValueDetail></apiValue><apiValue id="wprolog:TermList:wprolog:next"><apiName>next</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>wprolog:TermList</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="wprolog:TermList:numclauses"><apiName>numclauses</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>0</apiData><apiType value="int"/></apiValueDef></apiValueDetail></apiValue><apiValue id="wprolog:TermList:wprolog:term"><apiName>term</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>wprolog:Term</apiValueClassifier></apiValueDef></apiValueDetail></apiValue></apiClassifier><apiClassifier id="wprolog:Term"><apiName>Term</apiName><shortdesc> A Term is the basic data structure in Prolog.</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> A Term is the basic data structure in Prolog. 
There are three types of terms:
<ol>
<li> Values (ie. have a functor and arguments) </li>
<li> Variables (ie. unbound) </li>
<li>  References (bound to another variable) </li>
</ol>
</apiDesc></apiClassifierDetail><apiConstructor id="wprolog:Term:Term"><apiName>Term</apiName><shortdesc> This constructor is the simplest way to construct a term.</shortdesc><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>ps</apiItemName><apiOperationClassifier>wprolog:ParseString</apiOperationClassifier></apiParam></apiConstructorDef><apiDesc> This constructor is the simplest way to construct a term. The term is 
given in standard notation. 
Example <tt>Term(new ParseString("p(1,a(X,b))"))</tt>
</apiDesc></apiConstructorDetail><related-links><link href="wprolog.xml#ParseString"><linktext>ParseString</linktext></link></related-links></apiConstructor><apiOperation id="wprolog:Term:bind"><apiName>bind</apiName><shortdesc> Binds a variable to a term </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>t</apiItemName><apiOperationClassifier>wprolog:Term</apiOperationClassifier></apiParam></apiOperationDef><apiDesc> Binds a variable to a term </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:Term:getarg"><apiName>getarg</apiName><shortdesc> Retrieves an argument of a term </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiOperationClassifier>wprolog:Term</apiOperationClassifier></apiReturn><apiParam><apiItemName>pos</apiItemName><apiType value="int"/></apiParam></apiOperationDef><apiDesc> Retrieves an argument of a term </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:Term:getarity"><apiName>getarity</apiName><shortdesc> Gets the arity of a term </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiType value="int"/></apiReturn></apiOperationDef><apiDesc> Gets the arity of a term </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:Term:getfunctor"><apiName>getfunctor</apiName><shortdesc> Gets the functor of a term </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiType value="String"/></apiReturn></apiOperationDef><apiDesc> Gets the functor of a term </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:Term:refresh"><apiName>refresh</apiName><shortdesc> refresh creates new variables.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>wprolog:Term</apiOperationClassifier></apiReturn><apiParam><apiItemName>l</apiItemName><apiType value="Array"/></apiParam></apiOperationDef><apiDesc> refresh creates new variables. If the variables allready exist in 
its argument then they are used - this is used when parsing a clause so 
that variables throught the clause are shared.  Includes a copy operation </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:Term:setarg"><apiName>setarg</apiName><shortdesc> Used to set specific arguments.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>pos</apiItemName><apiType value="int"/></apiParam><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>wprolog:Term</apiOperationClassifier></apiParam></apiOperationDef><apiDesc> Used to set specific arguments. A primitive way of 
constructing terms is to create them with Term(s,f) and then 
build up the arguments. Using the parser is much simpler </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:Term:toString"><apiName>toString</apiName><shortdesc> Displays a term in standard notation </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiType value="String"/></apiReturn></apiOperationDef><apiDesc> Displays a term in standard notation </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:Term:unbind"><apiName>unbind</apiName><shortdesc> Unbinds a term -- ie.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc> Unbinds a term -- ie. resets it to a variable </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:Term:unify"><apiName>unify</apiName><shortdesc> Unification is the basic primitive operation in logic programming.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>t</apiItemName><apiOperationClassifier>wprolog:Term</apiOperationClassifier><apiDesc>- the stack is used to store the addresses of variables which are 
bound by the unification. This is needed when backtracking.
</apiDesc></apiParam><apiParam><apiItemName>s</apiItemName><apiOperationClassifier>wprolog:Stack</apiOperationClassifier></apiParam></apiOperationDef><apiDesc> Unification is the basic primitive operation in logic programming. 
</apiDesc></apiOperationDetail></apiOperation><apiValue id="wprolog:Term:wprolog:args"><apiName>args</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Array"/></apiValueDef></apiValueDetail></apiValue><apiValue id="wprolog:Term:wprolog:arity"><apiName>arity</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="int"/></apiValueDef></apiValueDetail></apiValue><apiValue id="wprolog:Term:wprolog:bound"><apiName>bound</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Boolean"/></apiValueDef></apiValueDetail></apiValue><apiValue id="wprolog:Term:wprolog:deref"><apiName>deref</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Boolean"/></apiValueDef></apiValueDetail></apiValue><apiValue id="wprolog:Term:wprolog:functor"><apiName>functor</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="String"/></apiValueDef></apiValueDetail></apiValue><apiValue id="wprolog:Term:internalparse"><apiName>internalparse</apiName><shortdesc>
Controls whether predicates can begin with an underscore.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiData>false</apiData><apiType value="Boolean"/></apiValueDef><apiDesc>
Controls whether predicates can begin with an underscore.
Beginning a system with an underscore makes in inaccessible 
to the user.
</apiDesc></apiValueDetail></apiValue><apiValue id="wprolog:Term:occurcheck"><apiName>occurcheck</apiName><shortdesc> Controls whether occurcheck is used in unification.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiData>false</apiData><apiType value="Boolean"/></apiValueDef><apiDesc> Controls whether occurcheck is used in unification.
Note that in version 1.0 the occurcheck was always performed
which accounted for the lower performance.
</apiDesc></apiValueDetail></apiValue><apiValue id="wprolog:Term:prettyprint"><apiName>prettyprint</apiName><shortdesc>
prettyprint controls printing of lists as [a,b]
rather than cons(a,cons(b,null))
</shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiData>true</apiData><apiType value="Boolean"/></apiValueDef><apiDesc>
prettyprint controls printing of lists as <tt>[a,b]</tt>
rather than <tt>cons(a,cons(b,null))</tt>
</apiDesc></apiValueDetail></apiValue><apiValue id="wprolog:Term:wprolog:ref"><apiName>ref</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>wprolog:Term</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="wprolog:Term:wprolog:varid"><apiName>varid</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="int"/></apiValueDef></apiValueDetail></apiValue><apiValue id="wprolog:Term:wprolog:varnum"><apiName>varnum</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiType value="int"/></apiValueDef></apiValueDetail></apiValue></apiClassifier><apiClassifier id="wprolog:OnceMark"><apiName>OnceMark</apiName><shortdesc> This is only used to implement once.</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> This is only used to implement <b>once</b>. </apiDesc></apiClassifierDetail><apiConstructor id="wprolog:OnceMark:OnceMark"><apiName>OnceMark</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="wprolog:TermListFactory"><apiName>TermListFactory</apiName><shortdesc/><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef></apiClassifierDetail><apiOperation id="wprolog:TermListFactory:create"><apiName>create</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiOperationClassifier>wprolog:TermList</apiOperationClassifier></apiReturn><apiParam><apiItemName>t</apiItemName><apiOperationClassifier>wprolog:Term</apiOperationClassifier></apiParam><apiParam><apiItemName>n</apiItemName><apiOperationClassifier>wprolog:TermList</apiOperationClassifier></apiParam><apiParam><apiItemName>d</apiItemName><apiOperationClassifier>wprolog:TermList</apiOperationClassifier><apiData>null</apiData></apiParam></apiOperationDef></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="wprolog:TermFactory"><apiName>TermFactory</apiName><shortdesc/><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef></apiClassifierDetail><apiOperation id="wprolog:TermFactory:create"><apiName>create</apiName><shortdesc> create a term with  a given functor and arity.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiOperationClassifier>wprolog:Term</apiOperationClassifier></apiReturn><apiParam><apiItemName>functor</apiItemName><apiType value="String"/><apiData/><apiDesc>- the functor
		</apiDesc></apiParam><apiParam><apiItemName>arity</apiItemName><apiType value="int"/><apiData>-1</apiData><apiDesc>- the arity
		</apiDesc></apiParam><apiParam><apiItemName>varnum</apiItemName><apiType value="int"/><apiData>-1</apiData></apiParam></apiOperationDef><apiDesc> create a term with  a given functor and arity.
		</apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="wprolog:ParseString"><apiName>ParseString</apiName><shortdesc> Parsing library </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> Parsing library </apiDesc></apiClassifierDetail><apiConstructor id="wprolog:ParseString:ParseString"><apiName>ParseString</apiName><shortdesc> Initialise variables </shortdesc><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>s</apiItemName><apiType value="String"/></apiParam><apiParam><apiItemName>tc</apiItemName><apiType value="mx.controls:TextArea"/></apiParam></apiConstructorDef><apiDesc> Initialise variables </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="wprolog:ParseString:advance"><apiName>advance</apiName><shortdesc> Move a character forward </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc> Move a character forward </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:ParseString:consult"><apiName>consult</apiName><shortdesc> This takes a hashtable and extends it with the clauses in the string.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiOperationClassifier>wprolog:Hashtable</apiOperationClassifier></apiReturn><apiParam><apiItemName>s</apiItemName><apiType value="String"/><apiDesc>- an initial program, it is augmented with the clauses parsed.
</apiDesc></apiParam><apiParam><apiItemName>db</apiItemName><apiOperationClassifier>wprolog:Hashtable</apiOperationClassifier><apiDesc>- a string representing a Prolog program 
</apiDesc></apiParam><apiParam><apiItemName>tc</apiItemName><apiType value="mx.controls:TextArea"/></apiParam></apiOperationDef><apiDesc> This takes a hashtable and extends it with the clauses in the string. 
</apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:ParseString:current"><apiName>current</apiName><shortdesc> Get the current character </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiType value="String"/></apiReturn></apiOperationDef><apiDesc> Get the current character </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:ParseString:empty"><apiName>empty</apiName><shortdesc> Is the parsestring empty? </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiType value="Boolean"/></apiReturn></apiOperationDef><apiDesc> Is the parsestring empty? </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:ParseString:getname"><apiName>getname</apiName><shortdesc> Recognise a name (sequence of alphanumerics) </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiType value="String"/></apiReturn></apiOperationDef><apiDesc> Recognise a name (sequence of alphanumerics) </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:ParseString:getnum"><apiName>getnum</apiName><shortdesc> Recognise a number </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="String"/></apiReturn></apiOperationDef><apiDesc> Recognise a number </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:ParseString:getvar"><apiName>getvar</apiName><shortdesc> Get the Term corresponding to a name.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiOperationClassifier>wprolog:Term</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc> Get the Term corresponding to a name. If the name is new, then create a 
new variable </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:ParseString:nextclause"><apiName>nextclause</apiName><shortdesc> This resets the variable dictionary.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc> This resets the variable dictionary. </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:ParseString:parseerror"><apiName>parseerror</apiName><shortdesc> Handle errors in one place </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>s</apiItemName><apiType value="String"/></apiParam></apiOperationDef><apiDesc> Handle errors in one place </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:ParseString:resolve"><apiName>resolve</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>db</apiItemName><apiOperationClassifier>wprolog:Hashtable</apiOperationClassifier></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="wprolog:ParseString:skipspace"><apiName>skipspace</apiName><shortdesc> Skip spaces.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc> Skip spaces. Also skips Prolog comments </apiDesc></apiOperationDetail></apiOperation><apiOperation id="wprolog:ParseString:toString"><apiName>toString</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiFinal/><apiReturn><apiType value="String"/></apiReturn></apiOperationDef></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="wprolog:Hashtable"><apiName>Hashtable</apiName><shortdesc/><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef></apiClassifierDetail><apiConstructor id="wprolog:Hashtable:Hashtable"><apiName>Hashtable</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="wprolog:Hashtable:get_"><apiName>get_</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="Object"/></apiReturn><apiParam><apiItemName>key</apiItemName><apiType value="String"/></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="wprolog:Hashtable:put"><apiName>put</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>key</apiItemName><apiType value="String"/></apiParam><apiParam><apiItemName>value</apiItemName><apiType value="Object"/></apiParam></apiOperationDef></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="wprolog:WPrologEditor"><apiName>WPrologEditor</apiName><shortdesc/><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>mx.binding:IBindingClient</apiBaseInterface><apiBaseInterface>mx.core:IDataRenderer</apiBaseInterface><apiBaseClassifier>mx.containers:VBox</apiBaseClassifier></apiClassifierDef><apiDesc></apiDesc></apiClassifierDetail><apiConstructor id="wprolog:WPrologEditor:WPrologEditor"><apiName>WPrologEditor</apiName><shortdesc>Constructor.</shortdesc><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>Constructor.</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="wprolog:WPrologEditor:protected:commitProperties"><apiName>commitProperties</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="protected"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="wprolog:WPrologEditor:dispose"><apiName>dispose</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef></apiOperationDetail></apiOperation><apiValue id="wprolog:WPrologEditor:program"><apiName>program</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty isBindable="true" name="Bindable"/><apiAccess value="public"/><apiDynamic/><apiType value="mx.controls:TextArea"/></apiValueDef><apiDesc></apiDesc></apiValueDetail></apiValue><apiValue id="wprolog:WPrologEditor:query"><apiName>query</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty isBindable="true" name="Bindable"/><apiAccess value="public"/><apiDynamic/><apiType value="mx.controls:TextArea"/></apiValueDef><apiDesc></apiDesc></apiValueDetail></apiValue><apiValue id="wprolog:WPrologEditor:resultsControl"><apiName>resultsControl</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty isBindable="true" name="Bindable"/><apiAccess value="public"/><apiDynamic/><apiType value="mx.controls:TextArea"/></apiValueDef><apiDesc></apiDesc></apiValueDetail></apiValue><apiValue id="wprolog:WPrologEditor:data:get"><apiName>data</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty isBindable="true" name="propertyChange"/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Object"/></apiValueDef></apiValueDetail></apiValue><apiValue id="wprolog:WPrologEditor:queryText:get"><apiName>queryText</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="String"/></apiValueDef></apiValueDetail></apiValue></apiClassifier></apiPackage>